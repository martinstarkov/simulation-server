syntax = "proto3";

package interface;

import "google/protobuf/empty.proto";

// ---------- Core types ----------

// Monotonic simulation step marker.
message Tick {
  uint64 seq   = 1;  // step sequence (0..N)
  float  time_s = 2; // seconds since simulation started (dt * seq)
}

// Optional: full observation/state snapshot pushed or returned via unary.
message Observation {
  repeated Object objects = 1;
  // add more fields as needed (e.g., environment params)
}

// Example dynamic object. Adjust to your engine’s schema.
message Object {
  uint32 id  = 1;
  Vec3   pos = 2;
  Quat   rot = 3;
}

message Vec3 { float x = 1; float y = 2; float z = 3; }
message Quat { float x = 1; float y = 2; float z = 3; float w = 4; }

// Controller → Simulator command (per-step inputs).
message ControlOutput {
  repeated ActuatorCmd actuators = 1;
}

message ActuatorCmd {
  uint32 id = 1;
  float  value = 2;
}

// Runtime parameter update (e.g., “wind = 2.0” from UI).
message ParamUpdate {
  string key       = 1;
  float  f32_value = 2;
}

// Reset the simulation (semantics are server-defined).
message ResetCommand {}

// Step synchronization command — sent by clients that participate
// in the stepping barrier (step_participant = true).
// When all such clients have sent StepReady, the server advances.
message StepReady {}

// Optional convenience for pushing error info down the stream.
message ErrorMsg {
  string message = 1;
}

message Shutdown {}

// ---------- Envelopes (wire format) ----------

message ClientMsg {
  uint64 client_id = 1;

  oneof body {
    ControlOutput   control      = 2;
    ParamUpdate     param_update = 3;
    ResetCommand    reset        = 4;
    StepReady       step_ready   = 5;
    Shutdown        shutdown     = 6;
  }
}

message ServerMsg {
  oneof body {
    Tick            tick       = 1;
    Observation     state      = 2; // optional push
    ErrorMsg        error_msg  = 3;
  }
}

message RegisterRequest {
  bool step_participant = 1; // if true, server waits for StepReady before stepping
}

message RegisterResponse {
  uint64 client_id = 1;
}

// ---------- Service ----------

service Forwarder {
  // Primary bidi stream. Clients send ClientMsg; server pushes ServerMsg.
  rpc Open(stream ClientMsg) returns (stream ServerMsg);

  // Registration RPC (returns client_id)
  rpc Register(RegisterRequest) returns (RegisterResponse);
}
