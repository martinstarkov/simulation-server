syntax = "proto3";

package interface;

import "google/protobuf/empty.proto";

// ---------- Core types ----------

// Monotonic simulation step marker.
message Tick {
  uint64 seq     = 1;  // step sequence (0..N)
  float  time_s = 2;  // seconds since simulation started (dt * seq)
}

// Optional: full observation/state snapshot pushed or returned via unary.
// Define to match your sim. A common pattern is a flat list of objects.
message Observation {
  repeated Object objects = 1;
  // add more fields as needed (e.g., environment params)
}

// Example dynamic object. Adjust to your engine’s schema.
message Object {
  uint32 id  = 1;
  Vec3   pos = 2;
  Quat   rot = 3;
}

message Vec3 { float x = 1; float y = 2; float z = 3; }
message Quat { float x = 1; float y = 2; float z = 3; float w = 4; }

// Controller → Simulator command (per-step inputs).
// Put your torques/velocities/etc. inside.
message ControlOutput {
  // example payloads; customize freely
  repeated ActuatorCmd actuators = 1;
}

message ActuatorCmd {
  uint32 id = 1;
  float  value = 2;
}

// Runtime parameter update (e.g., “wind = 2.0” from UI).
message ParamUpdate {
  string key       = 1;
  float  f32_value = 2;
}

// Reset the simulation (semantics are server-defined).
message ResetCommand {}

// Optional convenience for pushing error info down the stream.
message ErrorMsg {
  string message = 1;
}

// ---------- Envelopes (wire format) ----------

message ClientMsg {
  uint64 client_id = 1;

  oneof body {
    ControlOutput   control      = 2;
    ParamUpdate     param_update = 3;
    ResetCommand    reset        = 4;
  }
}

message ServerMsg {
  oneof body {
    Tick tick = 1;
    Observation      state      = 2; // optional push; servers may also expose unary GetLatestState
    ErrorMsg         error_msg  = 3;
  }
}

message RegisterRequest {
  bool step_participant = 1;
}

message RegisterResponse {
  uint64 client_id = 1;
}

// ---------- Service ----------

service Forwarder {
  // Primary bidi stream. Clients send ClientMsg; server pushes ServerMsg.
  rpc Open(stream ClientMsg) returns (stream ServerMsg);
  rpc Register(RegisterRequest) returns (RegisterResponse);
}
